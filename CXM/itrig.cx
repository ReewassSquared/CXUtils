package main
import "time"

var MT [624]i64
var index i64

type Random struct {
	seed i64
}

func (r Random) initgen () {
	i := 0
	MT[0] = r.seed
	for i = 1; i < 624; i++ {
		MT[i] = i64.bitand(i64.add(i64.mul(1812433253L, i64.bitxor(MT[i-1], i64.bitshr(MT[i-1], 30L))), i32.i64(i)), 4294967295L)
	}
}

func random (s i64) (out Random) {
	out = Random{ seed: s }
	out.initgen()
	index = 0L
}

func (r Random) genNumbers () {
	for i := 0; i < 623; i++ {
		var y i64
		y = i64.add(i64.bitand(MT[i], 2147483648L), i64.bitand(MT[i32.mod(i + 1, 624)], 2147483647L))
		MT[i] = i64.bitxor(MT[i32.mod(i + 397, 624)], i64.bitshr(y, 1L))
		if i64.mod(y, 2L) == 0L {
			MT[i] = i64.bitxor(MT[i], 2567483615L)
		}
	}
}

func (r Random) extractRandom () (out i64) {
	if index == 0L {
		r.genNumbers()
	}
	var y i64
	y = MT[index]
	y = i64.bitxor(y, i64.bitshr(y, 11L))
	y = i64.bitxor(y, i64.bitand(i64.bitshl(y, 7L), 2636928640L))
	y = i64.bitxor(y, i64.bitand(i64.bitshl(y, 15L), 4022730752L))
	y = i64.bitxor(y, i64.bitshr(y, 18L))
	index = i64.mod(index + 1L, 624L)
	out = y
}

func (r Random) drand () (out f64) {
	var special i64
	special = r.extractRandom()
	out = f64.div(i64.f64(special), 4294967295.0D)
}

func (r Random) frand () (out f32) {
	var special i64
	special = r.extractRandom()
	out = f32.div(i64.f32(special), 4294967295.0)
}

func (r Random) irand () (out i32) {
	var special i64
	special = r.extractRandom()
	out = i64.i32(special)
}

func (r Random) lrand () (out i64) {
	var special i64
	special = r.extractRandom()
	out = r.extractRandom()
	out = i64.bitor(i64.bitshl(special, 32L), out)
}

func (r Random) irange (low i32, high i32) (out i32) {
	var special i64
	special = r.extractRandom()
	special = i64.mod(special, i32.i64(high - low))
	out = i64.i32(i64.add(special, i32.i64(low)))
}

func (r Random) lrange (low i64, high i64) (out i64) {
	out = r.lrand()
	out = i64.mod(out, high - low)
	out = i64.add(out, low)
}

func (r Random) frange (low f32, high f32) (out f32) {
	out = r.frand()
	out = f32.mul(out, f32.sub(high, low))
	out = f32.add(out, low)
}

func (r Random) drange (low f64, high f64) (out f64) {
	out = r.drand()
	out = f64.mul(out, f64.sub(high, low))
	out = f64.add(out, low)
}

var atancoeff []f64 = []f64{ 0.4270785863924762004728563624667D, 0.3947364538712398451814067357191D, -0.03545533836905859909061078383274D, -0.001940941447856138956859495259266D, 0.001095092531973027678501853010573D, -0.0001026183743671634212429877308637D, -0.00001896686898285671534847632302423D, 0.000006367123995503800268651230925832D, -0.0000003319258372878539510819314098389D, -0.0000001798601236002728143148488015868D, 0.00000004156538225595988152824176390526D, 0.0000000001316360696444404624820680182158D, -0.000000001650412658979211924240474412405D, 0.0000000002684373248749809363214177639398D, 0.00000000002174139730011168179188608588456D, -0.0000000000145844384312476809316942892473D, 0.000000000001562005565039839681972648991194D, 0.0000000000003412212895050060050603369609291D, -0.0000000000001231570699372283684779849829752D, 0.000000000000007330407439908037354506682099453D }

var pgammacoeff []f64 = []f64{ -1.71618513886549492533811D, 24.7656508055759199108314D, -379.804256470945635097577D, 629.331155312818442661052D, 866.966202790413211295064D, -31451.2729688483675254357D, -36144.4134186911729807069D, 66456.1438202405440627855D }

var qgammacoeff []f64 = []f64{ -30.8402300119738975254353D, 315.350626979604161529144D, -1015.15636749021914166146D, -3107.77167157231109440444D, 22538.1184209801510330112D, 4755.84627752788110767815D, -134659.959864969306392456D, -115132.259675553483497211D }

var lgammacoeff []f64 = []f64{  0.08333333333333333333333333333333D, -0.002777777777777777777777777777778D, 0.0007936507936507936507936507936508D, -0.0005952380952380952380952380952381D, 0.0008417508417508417508417508417508D, -0.001917526917526917633674554686252D, 0.006410256410256410256410256410256D, -0.02955065359477124231624145522801D }

var agamcoeff []f64 = []f64{ 2.084415923538053986642658837738D, 0.042275268921800684221304767803D, 0.000005905456639988647088023171D, -0.000056497110599516283178411341D, 0.000004987442129576118947409608D, -0.000000010337467777524472180884D, -0.000000078110299754915990498736D, 0.000000014498554447836866472503D, -0.000000000948874604140955486866D, -0.000000000245085323134940876160D, 0.000000000100417021632937796250D, -0.000000000018330267793496677815D, 0.000000000000867218779978576352D, 0.000000000000679683469624925584D, -0.000000000000288250753888029128D, 0.000000000000064450790239311432D, -0.000000000000005844660777301642D, -0.000000000000002191799306335859D, 0.000000000000001360511699980453D, -0.000000000000000420796199750644D, 0.000000000000000077089354363348D, 0.000000000000000000633052293838D, -0.000000000000000007281797866527D, 0.000000000000000003522938407205D, -0.000000000000000001065421631145D, 0.000000000000000000193634717582D, 0.000000000000000000009226952412D, -0.000000000000000000025876677518D, 0.000000000000000000013204101565D, -0.000000000000000000004439112769D, 0.000000000000000000000980916518D, -0.000000000000000000000034134737D, -0.000000000000000000000100972407D, 0.000000000000000000000064750292D, -0.000000000000000000000026283259D, 0.000000000000000000000007643533D, -0.000000000000000000000001231005D, -0.000000000000000000000000271738D, 0.000000000000000000000000346373D, -0.000000000000000000000000185684D, 0.000000000000000000000000071428D, -0.000000000000000000000000019923D, 0.000000000000000000000000002625D, 0.000000000000000000000000001262D, -0.000000000000000000000000001269D, 0.000000000000000000000000000677D, -0.000000000000000000000000000269D, 0.000000000000000000000000000080D, -0.000000000000000000000000000012D, -0.000000000000000000000000000004D, 0.000000000000000000000000000005D, -0.000000000000000000000000000003D, 0.000000000000000000000000000001D }

var bgamcoeff []f64 = []f64{ 1.920583476254948200241829134328D, -0.038968237624892012141533182954D, 0.000783098024559588722963611440D, 0.000036507479093947186321985541D, -0.000006399552363250990346262930D, 0.000000250867644412461249757714D, 0.000000066429088714547461902130D, -0.000000016472719668006101561714D, 0.000000001522654032923526751875D, 0.000000000178294767802056875297D, -0.000000000102239735137571908376D, 0.000000000021131548802841964665D, -0.000000000001579766301957263953D, -0.000000000000589229005318213064D, 0.000000000000294265750239208743D, -0.000000000000071448375068673310D, 0.000000000000008040214030678725D, 0.000000000000001795718033819450D, -0.000000000000001350943903325037D, 0.000000000000000445310400416213D, -0.000000000000000088392150224802D, 0.000000000000000002449200580535D, 0.000000000000000006810693615141D, -0.000000000000000003569702427690D, 0.000000000000000001131165397918D, -0.000000000000000000222017658614D, -0.000000000000000000001180999223D, 0.000000000000000000024557198296D, -0.000000000000000000013344512573D, 0.000000000000000000004658360719D, -0.000000000000000000001086926183D, 0.000000000000000000000068916332D, 0.000000000000000000000093445505D, -0.000000000000000000000064545386D, 0.000000000000000000000027090508D, -0.000000000000000000000008155332D, 0.000000000000000000000001439319D, 0.000000000000000000000000210256D, -0.000000000000000000000000335833D, 0.000000000000000000000000187421D, -0.000000000000000000000000074017D, 0.000000000000000000000000021359D, -0.000000000000000000000000003194D, -0.000000000000000000000000001096D, 0.000000000000000000000000001242D, -0.000000000000000000000000000684D, 0.000000000000000000000000000278D, -0.000000000000000000000000000085D, 0.000000000000000000000000000015D, 0.000000000000000000000000000004D, -0.000000000000000000000000000005D, 0.000000000000000000000000000003D, -0.000000000000000000000000000001D }

var cgamcoeff []f64 = []f64{ 0.081859815904678132867937908794D, 0.040579741747366642257034689356D, -0.000404907931144698799131629808D, -0.000048897289375191931988707281D, 0.000005807953583619250489236122D, -0.000000126398282718429693139424D, -0.000000073449134703220165685808D, 0.000000015571158549445243897676D, -0.000000001230594521952879808979D, -0.000000000214161164077354401689D, 0.000000000101696976893897388713D, -0.000000000019745333287229064398D, 0.000000000001215142105272646241D, 0.000000000000637300238999434772D, -0.000000000000291757883116352078D, 0.000000000000067976604799256568D, -0.000000000000006925862151251366D, -0.000000000000002001264618792255D, 0.000000000000001357567451907062D, -0.000000000000000433293880496534D, 0.000000000000000082712525724804D, -0.000000000000000000878351279129D, -0.000000000000000007057211991064D, 0.000000000000000003548912249033D, -0.000000000000000001098579810742D, 0.000000000000000000207734840963D, 0.000000000000000000005275541308D, D, -0.000000000000000000025244470512D, 0.000000000000000000013281492164D, -0.000000000000000000004549724058D, 0.000000000000000000001033696592D, -0.000000000000000000000051294655D, -0.000000000000000000000097313164D, 0.000000000000000000000064680725D, -0.000000000000000000000026693664D, 0.000000000000000000000007899455D, -0.000000000000000000000001334338D, -0.000000000000000000000000241499D, 0.000000000000000000000000341305D, -0.000000000000000000000000186612D, 0.000000000000000000000000072733D, -0.000000000000000000000000020640D, 0.000000000000000000000000002907D, 0.000000000000000000000000001180D, -0.000000000000000000000000001256D, 0.000000000000000000000000000681D, -0.000000000000000000000000000274D, 0.000000000000000000000000000082D, -0.000000000000000000000000000014D, -0.000000000000000000000000000004D, 0.000000000000000000000000000005D, -0.000000000000000000000000000003D, 0.000000000000000000000000000001D }

func (r Random) rbin () (out bool) {
	var test f64
	test = r.drand()
	out = f64.gt(test, 0.5D)
}

func atan (x f64) (out f64) {
	var state f64
	state = x
	if state < 0.0D {
		x = f64.mul(-1.0D, x)
	}
	if state > 1.0D {
		x = f64.div(1.0D, x)
	}
	
	var tn f64
	var tp f64
	var t f64
	var u f64
	u = f64.sub(f64.mul(2.0D, x), 1.0D)
	tp = 1.0D
	t = u
	out = atancoeff[0]
	for i := 1; i < len(atancoeff); i++ {
		out = f64.add(out, f64.mul(t, atancoeff[i]))
		tn = f64.sub(f64.mul(f64.mul(u, t), 2.0D), tp)
		tp = t
		t = tn
	}
	if state < 0.0D {
		out = f64.mul(-1.0D, out)
	}
	if state > 1.0D {
		out = f64.sub(f64.mul(-1.0D, out), 1.57079632679489661923D)
	}
}

func atan2 (x f64, y f64) (out f64) {
	out = atan(f64.div(y, x))
}

func asin (x f64) (out f64) {
	out = f64.div(x, f64.sqrt(f64.sub(1.0D, f64.mul(x, x))))
	out = atan(out)
}

func acos (x f64) (out f64) {
	out = asin(x)
	out = f64.sub(1.57079632679489661923D, out)
}

func acot (x f64) (out f64) {
	out = atan(x)
	out = f64.sub(1.57079632679489661923D, out)
}

func asec (x f64) (out f64) {
	out = acos(f64.div(1.0D, x))
}

func acsc (x f64) (out f64) {
	out = asin(f64.div(1.0D, x))
}

func exp (x f64) (out f64) {
	out = f64.pow(2.71828182845904523536D, x) //cheating but that's fine
}

func log (x f64) (out f64) {
	out = f64.log(x) //more cheating
}

func log10 (x f64) (out f64) {
	out = f64.log10(x) //cheating!
}

func log2 (x f64) (out f64) {
	out = f64.log2(x) //cheating is good.
}

func sqrt (x f64) (out f64) {
	out = f64.log10(x) //cheating saves me time.
}

func sin (x f64) (out f64) {
	out = f64.sin(x) //cheating saves me money.
}

func cos (x f64) (out f64) {
	out = f64.cos(x) //cheating is great.
}

func sec (x f64) (out f64) {
	out = f64.div(1.0D, f64.cos(x))
}

func csc (x f64) (out f64) {
	out = f64.div(1.0D, f64.sin(x))
}

func floor (x f64) (out f64) {
	out = i64.f64(f64.i64(x))
}

func tan (x f64) (out f64) {
	test := f64.sub(f64.div(x, 3.14159265358979323846D), 0.5D)
	if test < 0.0000000001D && test > -0.0000000001D {
		out = pow(100000.0D, 1000.0D) //MARK FOR ERROR
	} else {
		out = f64.div(f64.sin(x), f64.cos(x))
	}
}

func erf (x f64) (out f64) {
	var state f64
	state = x
	if state < 0.0D {
		x = f64.mul(-1.0D, x)
	}
	
	if x < 0.5D {
		out = f64.mul(x, cbserfR1(f64.mul(x, x)))
	} else {
		var enx2 f64
		enx2 = exp(f64.mul(-1.0D, f64.mul(x, x)))
		if x < 4.0D {
			out = f64.sub(1.0D, f64.mul(enx2, cbserfR2(x)))
		} else {
			var onex2 f64
			onex2 = f64.div(1.0D, f64.mul(x, x))
			out = f64.sub(1.0D, f64.mul(f64.div(enx2, x), f64.add(0.564189583547756286948D, f64.mul(onex2, cbserfR3(onex2)))))
		}
	}
	if state < 0.0D {
		out = f64.mul(-1.0D, out)
	}
}

func erfc (x f64) (out f64) {
	out = f64.sub(1.0D, erf(x))
}

func npdf (x f64, u f64, v f64) (out f64) {
	var tv2 f64
	var expon f64
	var xmu f64
	xmu = f64.sub(x, u) //x - u
	tv2 = f64.mul(2.0D, f64.mul(v, v)) 
	expon = f64.mul(-1.0D, f64.div(f64.mul(xmu, xmu), tv2))
	out = f64.div(1.0D, f64.sqrt(f64.mul(3.14159265358979323846D, tv2)))
	out = f64.mul(out, exp(expon))
}

func ncdf (x f64, u f64, v f64) (out f64) {
	out = f64.mul(0.5D, f64.add(1.0D, erf(f64.div(f64.sub(x, u), f64.mul(v, 1.41421356237309504880D)))))
}

func tpdf (x f64, v i32) (out f64) {
	var t f64
	var expr f64
	var coeff f64
	t = i32.f64(v)
	invar := f64.div(f64.add(t, 1.0D), 2.0D)
	expon := f64.mul(invar, -1.0D)
	expr = f64.pow(f64.add(1.0D, f64.div(f64.mul(x, x), t)), expon)
	coeff = f64.div(gamma(invar), f64.mul(f64.sqrt(f64.mul(t, 3.14159265358979323846D)), gamma(f64.div(t, 2.0D))))
	out = f64.mul(coeff, expr)
}

func beta (x f64, y f64) (out f64) {
	out = f64.div(f64.mul(gamma(x), gamma(y)), gamma(f64.add(x, y)))
}

func gamma (x f64) (out f64) {
	if x <= 0.0D {
		out = pow(1000.0D, 1000000000.0D) //MARK FOR ERROR
		return
	}
	if x < 0.001D {
		out = f64.div(1.0D, f64.mul(x, f64.add(1.0D, f64.mul(0.577215664901532860606512090D, x))))
		return
	}
	if x < 12.0D {
		var y f64
		y = x
		var n i32
		n = 0
		var arg_l1 bool
		arg_l1 = (y < 1.0D)
		if arg_l1 {
			y = f64.add(1.0D, y)
		} else {
			n = i32.sub(f64.i32(floor(y)), 1) //ensures no accumulating errors!
			printf("%d\n", f64.i32(floor(y)))
			y = f64.sub(y, i32.f64(n))
		}
		var num f64
		var den f64
		num = 0.0D
		den = 1.0D
		var i i32
		var z f64
		z = f64.sub(y, 1.0D)
		for i = 0; i < 8; i++ {
			num = f64.mul(f64.add(num, pgammacoeff[i]), z)
			den = f64.add(f64.mul(den, z), qgammacoeff[i])
		}
		var result f64
		result = f64.add(f64.div(num, den), 1.0D)

		if arg_l1 {
			result = f64.div(result, f64.sub(y, 1.0D))
		} else {
			for i = 0; i < n; i++ {
				result = f64.mul(result, y)
				y = f64.add(y, 1.0D)
			}
		}
		out = result
		return
	}
	if x > 171.624D {
		out = f64.pow(1000000.0D, 1000000.0D)
		return
	}
	out = lgamma(x)
	out = exp(out)
}

func invgamma (x f64) (out f64) {
	var begin f64
	begin = f64.mul(0.398942280401432677939946059934D, f64.mul(f64.pow(x, f64.sub(0.5D, x)), exp(x)))
	var tn f64
	var tp f64
	var t f64
	var u f64
	u = f64.div(1.0D, x)
	u = f64.sub(f64.mul(2.0D, u), 1.0D)
	tp = 1.0D
	t = u
	out = f64.mul(0.5D, bgamcoeff[0])
	for i := 1; i < len(bgamcoeff); i++ {
		out = f64.add(out, f64.mul(t, bgamcoeff[i]))
		tn = f64.sub(f64.mul(f64.mul(2.0D, u), t), tp)
		tp = t
		t = tn
	}
	out = f64.mul(out, begin)
}

func digamma (x f64) (out f64) {
	
}

func lgamma (x f64) (out f64) {
	if x <= 0.0D {
		out = pow(1000.0D, 1000000000.0D) //MARK FOR ERROR
		return
	}
	if x < 12.0D {
		out = gamma(x)
		out = f64.abs(out)
		out = f64.log(out)
		return
	}
	var z f64
	z = f64.div(1.0D, f64.mul(x, x))
	var sum f64
	sum = lgammacoeff[7]
	for i := 6; i >= 0; i-- {
		sum = f64.mul(sum, z)
		sum = f64.add(sum, lgammacoeff[i])
	}
	var series f64
	series = f64.div(sum, x)
	var lgam f64
	lgam = f64.add(f64.add(f64.sub(f64.mul(f64.sub(x, 0.5D), f64.log(x)), x), 0.91893853320467274178032973640562D), series)
	out = lgam
}

func cbserfR3 (x f64) (out f64) {
	var num f64
	var den f64
	x2 := f64.mul(x, x)
	x4 := f64.mul(x2, x2)
	x5 := f64.mul(x, x4)
	x3 := f64.mul(x, x2)

	num = -0.000658749161529837803157D
	num = f64.add(num, f64.mul(-0.0163153871373020978498D, x5))
	num = f64.add(num, f64.mul(-0.305326634961232344035D, x4))
	num = f64.add(num, f64.mul(-0.360344899949804439429D, x3))
	num = f64.add(num, f64.mul(-0.125781726111229246204D, x2))
	num = f64.add(num, f64.mul(-0.0160837851487422766278D, x))

	den = 0.00233520497626869185443D
	den = f64.mul(den, x5)
	den = f64.add(den, f64.mul(2.56852019228982242072D, x4))
	den = f64.add(den, f64.mul(1.87295284992346047209D, x3))
	den = f64.add(den, f64.mul(0.527905102951428412248D, x2))
	den = f64.add(den, f64.mul(0.0605183413124413191178D, x))
	out = f64.div(num, den)
}

func cbserfR2 (x f64) (out f64) {
	var num f64
	var den f64
	x2 := f64.mul(x, x)
	x4 := f64.mul(x2, x2)
	x3 := f64.mul(x, x2)
	x8 := f64.mul(x4, x4)
	x6 := f64.mul(x2, x4)
	x5 := f64.mul(x, x4)
	x7 := f64.mul(x3, x4)
	num = 1230.33935479799725272D
	num = f64.add(num, f64.mul(0.0000000215311535474403846343D, x8))
	num = f64.add(num, f64.mul(0.564188496988670089180D, x7))
	num = f64.add(num, f64.mul(8.88314979438837594118D, x6))
	num = f64.add(num, f64.mul(66.1191906371416294775D, x5))
	num = f64.add(num, f64.mul(298.635138197400131132D, x4))
	num = f64.add(num, f64.mul(881.952221241769090411D, x3))
	num = f64.add(num, f64.mul(1712.04761263407058314D, x2))
	num = f64.add(num, f64.mul(2051.07837782607146532D, x))
	den = 1230.33935480374942043D
	den = f64.add(den, x8)
	den = f64.add(den, f64.mul(15.7449261107098347253D, x7))
	den = f64.add(den, f64.mul(117.693950891312499305D, x6))
	den = f64.add(den, f64.mul(537.181101862009857509D, x5))
	den = f64.add(den, f64.mul(1621.38957456669018874D, x4))
	den = f64.add(den, f64.mul(3290.79923573345962678D, x3))
	den = f64.add(den, f64.mul(4362.61909014324715820D, x2))
	den = f64.add(den, f64.mul(3439.36767414372163696D, x))
	out = f64.div(num, den)
}

func cbserfR1 (x f64) (out f64) {
	var num f64
	var den f64
	x2 := f64.mul(x, x)
	x4 := f64.mul(x2, x2)
	x3 := f64.mul(x, x2)
	num = 3209.377589138469472562D
	num = f64.add(num, f64.mul(377.4852376853020208137D, x))
	num = f64.add(num, f64.mul(113.8641541510501556495D, x2))
	num = f64.add(num, f64.mul(3.161123743870565596947D, x3))
	num = f64.add(num, f64.mul(0.185777706184603152673D, x4))
	den = 2844.236833439170622273D
	den = f64.add(den, f64.mul(1282.616526077372275645D, x))
	den = f64.add(den, f64.mul(244.0246379344441733056D, x2))
	den = f64.add(den, f64.mul(23.60129095234412093499D, x3))
	den = f64.add(den, x4)
	out = f64.div(num, den)
}

func cot (x f64) (out f64) {
	test := f64.div(x, 3.14159265358979323846D)
	if test < 0.0000000001D && test > -0.0000000001D {
		out = pow(100000.0D, 1000.0D)
	} else {
		out = f64.div(f64.cos(x), f64.sin(x))
	}
}

func pow (b f64, e f64) (out f64) {
	out = f64.pow(b, e)
}

func main () {
	//var g []f64
	//g = resize(g, 100000)
	//var randomgen Random
	//randomgen = random(12345L)
	//for i := 0; i < 100000; i++ {
	//	g[i] = randomgen.drange(-5.0D, 5.0D)
	//}
	var ans f64
	//start := time.UnixMilli()
	//
	//for i := 0; i < 100000; i++ {
	//	ans = atan(g[i])
	//}
	//end := time.UnixMilli()
	//printf("100,000 ops atan (seconds): %f", f64.div(f64.sub(i64.f64(end), i64.f64(start)), 1000.0D))
	var viasd f64
	viasd = 4.0D
	ans = invgamma(viasd)
	printf("in: %f res: %f\n", viasd, ans)
}